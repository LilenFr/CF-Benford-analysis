[
  {
    "objectID": "CF-Benford-analysis.html",
    "href": "CF-Benford-analysis.html",
    "title": "Algo extra√±o sucede en el departamento de contabilidad‚Ä¶ üëª",
    "section": "",
    "text": "Resumen: En el presente cuaderno se aplica el an√°lisis de Benford a documentos contables previamente procesados. Esto con el fin de investigar la veracidad de una supuesta manipulaci√≥n de datos en transacciones financieras con proveedores.\nObjetivos:"
  },
  {
    "objectID": "CF-Benford-analysis.html#importar-librer√≠as-utilidades-y-cargar-datos",
    "href": "CF-Benford-analysis.html#importar-librer√≠as-utilidades-y-cargar-datos",
    "title": "Algo extra√±o sucede en el departamento de contabilidad‚Ä¶ üëª",
    "section": "Importar librer√≠as, utilidades y cargar datos",
    "text": "Importar librer√≠as, utilidades y cargar datos\n\n# Importar\nimport pandas as pd\nimport math\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport seaborn as sns\nimport warnings\nwarnings.filterwarnings('ignore')\n\nPara este cuaderno, hay dos tablas descargadas del sistema SAP:\n\nBSEG.csv: Almacena los detalles de las transacciones contables.\nBKPF.csv: Almacena los registros principales de los documentos contables.\n\n\n# Cargar datos\nbseg = pd.read_csv('./datos/BSEG.csv', low_memory=False)\nbkpf = pd.read_csv('./datos/BKPF.csv', low_memory=False)\n\nAmbas tablas contienen varias columnas.\n\nbseg.columns\n\nIndex(['Unnamed: 0', 'MANDT', 'BUKRS', 'BELNR', 'GJAHR', 'BUZEI', 'BUZID',\n       'AUGDT', 'AUGCP', 'AUGBL',\n       ...\n       'PEROP_END', 'FASTPAY', 'IGNR_IVREF', 'FMFGUS_KEY', 'FMXDOCNR',\n       'FMXYEAR', 'FMXDOCLN', 'FMXZEKKN', 'PRODPER', 'RECRF'],\n      dtype='object', length=337)\n\n\n\nbkpf.columns\n\nIndex(['Unnamed: 0', 'MANDT', 'BUKRS', 'BELNR', 'GJAHR', 'BLART', 'BLDAT',\n       'BUDAT', 'MONAT', 'CPUDT',\n       ...\n       'SSBLK', 'BATCH', 'SNAME', 'SAMPLED', 'EXCLUDE_FLAG', 'BLIND',\n       'OFFSET_STATUS', 'OFFSET_REFER_DAT', 'PENRC', 'KNUMV'],\n      dtype='object', length=114)"
  },
  {
    "objectID": "CF-Benford-analysis.html#bkpf",
    "href": "CF-Benford-analysis.html#bkpf",
    "title": "Algo extra√±o sucede en el departamento de contabilidad‚Ä¶ üëª",
    "section": "BKPF",
    "text": "BKPF\nSin embargo, de BKPF, solo son necesarias las siguientes columnas:\n\nBELNR - El n√∫mero del documento contable.\nBLART - El tipo de documento.\nUSNAM - El usuario contador que registr√≥ el documento.\n\n\n# Reducir el DataFrame a las columnas de inter√©s\nbkpf = bkpf.loc[:, ['BELNR', 'BLART', 'USNAM']]\n\n\n# Obtener una muestra replicable y aleatoria de 10 filas\nbkpf.sample(10, random_state=456)\n\n\n\n\n\n\n\n\nBELNR\nBLART\nUSNAM\n\n\n\n\n887\n4900000573\nWA\nBOETTCHER\n\n\n1183\n4900000869\nWA\nBOETTCHER\n\n\n2547\n5000000184\nWE\nGBIFAC-01\n\n\n690\n4900000376\nWA\nBOETTCHER\n\n\n1280\n4900000966\nWA\nBOETTCHER\n\n\n19\n1500000013\nKZ\nGBI-005\n\n\n2778\n5000000415\nWE\nGBI-005\n\n\n2266\n4900001952\nWA\nBOETTCHER\n\n\n1013\n4900000699\nWA\nBOETTCHER\n\n\n3262\n1500000304\nKZ\nGBIFAC-01\n\n\n\n\n\n\n\n\n# Obtener los valores √∫nicos de la columna 'BLART' \nbkpf['BLART'].unique()\n\narray(['RV', 'DZ', 'KZ', 'KG', 'WA', 'WL', 'WE', 'RE'], dtype=object)\n\n\nEl tipo de documento relevante aqu√≠ es KZ, que representa los pagos a los proveedores.\n\n# Filtrar solo el tipo de documento 'KZ'\nbkpf = bkpf[bkpf['BLART']=='KZ']\n\n\nbkpf.head()\n\n\n\n\n\n\n\n\nBELNR\nBLART\nUSNAM\n\n\n\n\n6\n1500000000\nKZ\nGBI-005\n\n\n7\n1500000001\nKZ\nGBI-005\n\n\n8\n1500000002\nKZ\nGBI-005\n\n\n9\n1500000003\nKZ\nGBI-005\n\n\n10\n1500000004\nKZ\nGBI-005\n\n\n\n\n\n\n\nEl DataFrame final consta de informaci√≥n sobre los pagos a proveedores. Espec√≠ficamente, el n√∫mero del documento y el contador que lo registr√≥."
  },
  {
    "objectID": "CF-Benford-analysis.html#bseg",
    "href": "CF-Benford-analysis.html#bseg",
    "title": "Algo extra√±o sucede en el departamento de contabilidad‚Ä¶ üëª",
    "section": "BSEG",
    "text": "BSEG\nDe esta tabla solo importan las siguientes columnas:\n\nBELNR - El n√∫mero del documento contable.\nBSCHL - La clave de contabilizaci√≥n.\nWRBTR - El valor monetario o valor contable.\nLIFNR - La cuenta del proveedor.\n\n\n# Reducir el DataFrame a las columnas de inter√©s\nbseg = bseg.loc[:, ['BELNR', 'BSCHL', 'WRBTR', 'LIFNR']]\n\n\n# Obtener una muestra replicable y aleatoria de 10 filas\nbseg.sample(10, random_state=456)\n\n\n\n\n\n\n\n\nBELNR\nBSCHL\nWRBTR\nLIFNR\n\n\n\n\n559\n1.500000e+09\n25\n1,000.00\n125131.0\n\n\n235\n1.500000e+09\n50\n5\nNaN\n\n\n619\n1.700000e+09\n35\n1,960,000.00\n125088.0\n\n\n32\n1.500000e+09\n50\n1,010,000.00\nNaN\n\n\n2737\n1.500000e+09\n50\n1927.48\nNaN\n\n\n425\n1.500000e+09\n50\n1,000,000.00\nNaN\n\n\n2527\n5.105600e+09\n31\n96,000.00\n125108.0\n\n\n2808\n1.500000e+09\n25\n1,000.00\n125107.0\n\n\n943\n5.000000e+09\n96\n63,830.00\n125018.0\n\n\n557\n1.500000e+09\n25\n1,000.00\n125131.0\n\n\n\n\n\n\n\n\n# Obtener los valores √∫nicos de la columna 'BSCHL' \nbseg['BSCHL'].unique()\n\narray([50, 25, 40, 35, 89, 96, 86, 99, 81, 91, 31, 83, 93, 21])\n\n\nLa clave de contabilizaci√≥n relevante aqu√≠ es 25, que representa un registro contable de d√©bito en la cuenta de proveedor, lo que significa que se ha realizado una compra o un gasto con el proveedor.\n\n# Filtrar solo la clave de contabilizaci√≥n '25'\nbseg = bseg[bseg['BSCHL']==25]\n\n\n# Ver el tipo de dato de las columnas\nbseg.dtypes\n\nBELNR    float64\nBSCHL      int64\nWRBTR     object\nLIFNR    float64\ndtype: object\n\n\n\n# Eliminar la separaci√≥n de miles en 'WRBTR'\nbseg['WRBTR'] = bseg['WRBTR'].str.replace(',', '')\n\n\nbseg.head()\n\n\n\n\n\n\n\n\nBELNR\nBSCHL\nWRBTR\nLIFNR\n\n\n\n\n1\n1.500000e+09\n25\n213710.00\n125131.0\n\n\n3\n1.500000e+09\n25\n1068550.00\n125131.0\n\n\n5\n1.500000e+09\n25\n933153.41\n125135.0\n\n\n7\n1.500000e+09\n25\n1050.00\n125135.0\n\n\n9\n1.500000e+09\n25\n30300.00\n125131.0\n\n\n\n\n\n\n\nEl DataFrame final consta de informaci√≥n sobre los gastos con proveedores. Espec√≠ficamente, el n√∫mero del documento, el valor contable y la cuenta del proveedor al que se le deposit√≥.\nPero eso no es todo‚Ä¶\n\nObtener el primer d√≠gito del valor contable\n\n# ...y crear una nueva columna con √©l:\nbseg['FIRST'] = bseg['WRBTR'].str[0:1].astype(int)\nbseg['FIRST']\n\n1       2\n3       1\n5       9\n7       1\n9       3\n       ..\n2802    1\n2804    1\n2806    1\n2808    1\n2810    1\nName: FIRST, Length: 353, dtype: int64\n\n\nEsto ser√° √∫til m√°s adelante.\n\n\nSeleccionar solo los proveedores con m√°s de 20 documentos\n\n# ¬øCu√°ntos documentos hay por proveedor?\nvendors = bseg.groupby('LIFNR').size().sort_values(ascending=False)\nvendors\n\nLIFNR\n125131.0    122\n125135.0    118\n125134.0     47\n125104.0     31\n125107.0     22\n125105.0      4\n125121.0      3\n125000.0      1\n125014.0      1\n125070.0      1\n125098.0      1\n125101.0      1\n125127.0      1\ndtype: int64\n\n\n\n# Filtrar los proveedores con m√°s de 20 documentos\nvendors = vendors[vendors &gt; 20]\nvendors\n\nLIFNR\n125131.0    122\n125135.0    118\n125134.0     47\n125104.0     31\n125107.0     22\ndtype: int64\n\n\n\nvendors.index\n\nIndex([125131.0, 125135.0, 125134.0, 125104.0, 125107.0], dtype='float64', name='LIFNR')\n\n\n\n# Seleccionar proveedores de inter√©s\nbseg = bseg[bseg['LIFNR'].isin(vendors.index)]\n\n\nbseg.head()\n\n\n\n\n\n\n\n\nBELNR\nBSCHL\nWRBTR\nLIFNR\nFIRST\n\n\n\n\n1\n1.500000e+09\n25\n213710.00\n125131.0\n2\n\n\n3\n1.500000e+09\n25\n1068550.00\n125131.0\n1\n\n\n5\n1.500000e+09\n25\n933153.41\n125135.0\n9\n\n\n7\n1.500000e+09\n25\n1050.00\n125135.0\n1\n\n\n9\n1.500000e+09\n25\n30300.00\n125131.0\n3"
  },
  {
    "objectID": "CF-Benford-analysis.html#integrar-dataframes-y-crear-variables-para-el-an√°lisis-benford",
    "href": "CF-Benford-analysis.html#integrar-dataframes-y-crear-variables-para-el-an√°lisis-benford",
    "title": "Algo extra√±o sucede en el departamento de contabilidad‚Ä¶ üëª",
    "section": "Integrar DataFrames y crear variables para el an√°lisis Benford",
    "text": "Integrar DataFrames y crear variables para el an√°lisis Benford\n\n# Integrar ambas tablas utilizando la columna 'BELNR' (n√∫mero del doc. contable) como clave primaria\nvc = pd.merge(bseg, bkpf, how='left', on='BELNR')\nvc\n\n\n\n\n\n\n\n\nBELNR\nBSCHL\nWRBTR\nLIFNR\nFIRST\nBLART\nUSNAM\n\n\n\n\n0\n1.500000e+09\n25\n213710.00\n125131.0\n2\nKZ\nGBI-005\n\n\n1\n1.500000e+09\n25\n1068550.00\n125131.0\n1\nKZ\nGBI-005\n\n\n2\n1.500000e+09\n25\n933153.41\n125135.0\n9\nKZ\nGBI-005\n\n\n3\n1.500000e+09\n25\n1050.00\n125135.0\n1\nKZ\nGBI-005\n\n\n4\n1.500000e+09\n25\n30300.00\n125131.0\n3\nKZ\nGBI-005\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n335\n1.500000e+09\n25\n1000.00\n125107.0\n1\nKZ\nGBIFAC-01\n\n\n336\n1.500000e+09\n25\n1000.00\n125107.0\n1\nKZ\nGBIFAC-01\n\n\n337\n1.500000e+09\n25\n1000.00\n125107.0\n1\nKZ\nGBIFAC-01\n\n\n338\n1.500000e+09\n25\n1000.00\n125107.0\n1\nKZ\nGBIFAC-01\n\n\n339\n1.500000e+09\n25\n1000.00\n125131.0\n1\nNaN\nNaN\n\n\n\n\n340 rows √ó 7 columns\n\n\n\n\nCrear variables - La ley de Benford\n\n'''\nContar el n√∫mero de veces que aparece cada combinaci√≥n √∫nica de valores en 'FIRST' y 'LIFNR'\nen el DataFrame vc y crear un nuevo DataFrame llamado ben_vc_vendor que resuma esa informaci√≥n.\n'''\nben_vc_vendor = vc.groupby(['FIRST', 'LIFNR'])['FIRST'].count().reset_index(name='COUNT')\nben_vc_vendor\n\n\n\n\n\n\n\n\nFIRST\nLIFNR\nCOUNT\n\n\n\n\n0\n1\n125104.0\n2\n\n\n1\n1\n125107.0\n20\n\n\n2\n1\n125131.0\n72\n\n\n3\n1\n125134.0\n3\n\n\n4\n1\n125135.0\n74\n\n\n5\n2\n125131.0\n18\n\n\n6\n2\n125134.0\n2\n\n\n7\n2\n125135.0\n18\n\n\n8\n3\n125107.0\n1\n\n\n9\n3\n125131.0\n7\n\n\n10\n3\n125135.0\n7\n\n\n11\n4\n125104.0\n2\n\n\n12\n4\n125131.0\n8\n\n\n13\n4\n125135.0\n5\n\n\n14\n5\n125104.0\n8\n\n\n15\n5\n125131.0\n4\n\n\n16\n5\n125135.0\n4\n\n\n17\n6\n125104.0\n4\n\n\n18\n6\n125131.0\n4\n\n\n19\n6\n125135.0\n3\n\n\n20\n7\n125104.0\n8\n\n\n21\n7\n125107.0\n1\n\n\n22\n7\n125131.0\n5\n\n\n23\n7\n125134.0\n6\n\n\n24\n7\n125135.0\n3\n\n\n25\n8\n125104.0\n3\n\n\n26\n8\n125131.0\n1\n\n\n27\n8\n125134.0\n18\n\n\n28\n9\n125104.0\n4\n\n\n29\n9\n125131.0\n3\n\n\n30\n9\n125134.0\n18\n\n\n31\n9\n125135.0\n4\n\n\n\n\n\n\n\nDe este modo se obtiene la cantidad de veces (COUNT) que el primer d√≠gito del valor contable (FIRST) se repite para cada proveedor (LIFNR).\n\n'''\nContar el n√∫mero de veces que aparece cada combinaci√≥n √∫nica de valores en 'FIRST' y 'USNAM'\nen el DataFrame vc y crear un nuevo DataFrame llamado ben_vc_vendor que resuma esa informaci√≥n.\n'''\nben_vc_accountant = vc.groupby(['FIRST', 'USNAM'])['FIRST'].count().reset_index(name='COUNT')\nben_vc_accountant\n\n\n\n\n\n\n\n\nFIRST\nUSNAM\nCOUNT\n\n\n\n\n0\n1\nGBI-005\n28\n\n\n1\n1\nGBI-026\n83\n\n\n2\n1\nGBIFAC-01\n59\n\n\n3\n2\nGBI-005\n17\n\n\n4\n2\nGBI-026\n7\n\n\n5\n2\nGBIFAC-01\n14\n\n\n6\n3\nGBI-005\n3\n\n\n7\n3\nGBI-026\n9\n\n\n8\n3\nGBIFAC-01\n3\n\n\n9\n4\nGBI-026\n12\n\n\n10\n4\nGBIFAC-01\n3\n\n\n11\n5\nGBI-005\n3\n\n\n12\n5\nGBI-026\n10\n\n\n13\n5\nGBIFAC-01\n3\n\n\n14\n6\nGBI-005\n2\n\n\n15\n6\nGBI-026\n8\n\n\n16\n6\nGBIFAC-01\n1\n\n\n17\n7\nGBI-026\n15\n\n\n18\n7\nGBIFAC-01\n8\n\n\n19\n8\nGBI-026\n4\n\n\n20\n8\nGBIFAC-01\n18\n\n\n21\n9\nGBI-005\n2\n\n\n22\n9\nGBI-026\n6\n\n\n23\n9\nGBIFAC-01\n21\n\n\n\n\n\n\n\nDe este modo se obtiene la cantidad de veces (COUNT) que el primer d√≠gito del valor contable (FIRST) se repite para cada contador (USNAM)."
  },
  {
    "objectID": "CF-Benford-analysis.html#an√°lisis-de-benford",
    "href": "CF-Benford-analysis.html#an√°lisis-de-benford",
    "title": "Algo extra√±o sucede en el departamento de contabilidad‚Ä¶ üëª",
    "section": "An√°lisis de Benford",
    "text": "An√°lisis de Benford\n\n# Crear una lista con los valores de la ley de Benford para los primeros 9 d√≠gitos\nbenford = [math.log10(1 + 1 / d)*100 for d in range(1, 10)]\n\n'''\nLa ley de Benford establece que, en muchos conjuntos de datos del mundo real,\nlos d√≠gitos iniciales de los n√∫meros siguen una distribuci√≥n no uniforme, donde el d√≠gito \"1\"\nes el m√°s com√∫n, seguido del \"2\", \"3\" y as√≠ sucesivamente, hasta que el d√≠gito \"9\" es el menos com√∫n. \n\nLa f√≥rmula para calcular la ley de Benford es log10(1 + 1/d), donde 'd' es el d√≠gito que se est√° analizando.\n'''\n\n# Crear un diccionario con dos claves: 'n' y 'b'.\n# 'n' es una lista de n√∫meros enteros del 1 al 9 y 'b' es la lista benford creada anteriormente\nd = {'n': range(1, 10), 'b': benford}\n\n# Utilizar el diccionario para crear un nuevo DataFrame con dos columnas:\n# La columna 'n', que contiene los n√∫meros enteros del 1 al 9 y\n# la columna 'b', que contiene los valores de la ley de Benford correspondientes a cada d√≠gito\nben_predict = pd.DataFrame(d)\nben_predict\n\n\n\n\n\n\n\n\nn\nb\n\n\n\n\n0\n1\n30.103000\n\n\n1\n2\n17.609126\n\n\n2\n3\n12.493874\n\n\n3\n4\n9.691001\n\n\n4\n5\n7.918125\n\n\n5\n6\n6.694679\n\n\n6\n7\n5.799195\n\n\n7\n8\n5.115252\n\n\n8\n9\n4.575749\n\n\n\n\n\n\n\n\n# Graficar\nsns.pointplot(\n    x = 'n',\n    y = 'b',\n    data = ben_predict,\n    color = 'black'\n);\n\n\n\n\nEste gr√°fico representa la distribuci√≥n de Benford y muestra c√≥mo cambia la probabilidad de que un n√∫mero comience con un d√≠gito espec√≠fico en funci√≥n del n√∫mero en s√≠ mismo.\n\nGraficar el valor contable por proveedor\n\nsns.pointplot(\n    x = 'FIRST',\n    y = 'COUNT',\n    hue = 'LIFNR',\n    data = ben_vc_vendor\n);\n\nsns.pointplot(\n    x = 'n',\n    y = 'b',\n    data = ben_predict,\n    color = 'black'\n);\n\n\n\n\nEste gr√°fico representa la cantidad de veces (eje y) que se repite un determinado primer d√≠gito (eje x) en el valor contable depositado a los proveedores. Por ejemplo, tenemos que la cuenta de proveedor 125135.0 (violeta) registra arriba de 70 veces que un valor contable comienza con el d√≠gito 1 y abajo de 20 veces que comienza con el d√≠gito 2.\nEste gr√°fico tambien tiene superpuesta la distribuci√≥n de Benford (negro), a la que casi todas las cuentas de proveedores responden adecuadamente.\n\n‚ö†Ô∏è Anomal√≠a en los valores contables La cuenta de proveedor 125134.0 (rojo) se comporta de manera extra√±a, mostrando mayor cantidad de valores iniciados con d√≠gitos como 9, 8 y 7 que con d√≠gitos como 1 y 2.\n\n\n\nGraficar el valor contable por contador\n\nsns.pointplot(\n    x = 'FIRST',\n    y = 'COUNT',\n    hue = 'USNAM',\n    data = ben_vc_accountant\n);\n\nsns.pointplot(\n    x = 'n',\n    y = 'b',\n    data = ben_predict,\n    color = 'black'\n);\n\n\n\n\nEste gr√°fico representa la cantidad de veces (eje y) que se repite un determinado primer d√≠gito (eje x) en el valor contable registrado por los contadores. Por ejemplo, tenemos que el contador GBI-026 (naranja) registra m√°s de 80 veces que un valor contable comienza con el d√≠gito 1.\n\n‚ö†Ô∏è Anomal√≠a en los valores contables: El contador GBIFAC-01 (verde) se comporta de manera extra√±a, mostrando una cantidad irregular de valores iniciados con d√≠gitos como 9, 8 y 7.\n\n\n‚ö†Ô∏è Anomal√≠a en los valores contables: El contador GBIFAC-01 (verde) y La cuenta de proveedor 125134.0 (rojo) parecen sugerir una posible manipulaci√≥n o alteraci√≥n de datos."
  },
  {
    "objectID": "CF-Benford-analysis.html#qui√©n-es-gbifac-01-y-qu√©-pas√≥",
    "href": "CF-Benford-analysis.html#qui√©n-es-gbifac-01-y-qu√©-pas√≥",
    "title": "Algo extra√±o sucede en el departamento de contabilidad‚Ä¶ üëª",
    "section": "¬øQui√©n es GBIFAC-01 y qu√© pas√≥?",
    "text": "¬øQui√©n es GBIFAC-01 y qu√© pas√≥?\n\n# Contar el n√∫mero de filas en el DataFrame vc donde la columna 'USNAM' sea igual a 'GBIFAC-01',\nre1 = len(vc[(vc['USNAM']=='GBIFAC-01')])\nprint(f'El n√∫mero de documentos que el contador GBIFAC-01 registr√≥ en total es de: {re1}')\n\nEl n√∫mero de documentos que el contador GBIFAC-01 registr√≥ en total es de: 130\n\n\n\nvc_total = vc[vc['USNAM'] == 'GBIFAC-01']['WRBTR'].astype(float).sum()\nprint(f\"El valor contable total registrado por GBIFAC-01 es de: {vc_total}\")\n\nEl valor contable total registrado por GBIFAC-01 es de: 32713437.64\n\n\n\n# Contar el n√∫mero de filas en el DataFrame vc que cumpla las siguientes condiciones:\n# la columna 'USNAM' debe ser igual a 'GBIFAC-01',\n# la columna 'FIRST' debe ser uno de los valores [7, 8, 9]\n# la columna 'LIFNR' no debe ser igual a 125134\nre2 = len(vc[(vc['USNAM']=='GBIFAC-01') & (vc['FIRST'].isin([7, 8, 9])) & (vc['LIFNR'] != 125134)])\n\nprint(f'El n√∫mero de documentos que el contador GBIFAC-01 registr√≥ \\n * con valores contables at√≠picos \\n * para proveedores que no responden a la cuenta 125134.0 \\n es de: {re2}')\n\nEl n√∫mero de documentos que el contador GBIFAC-01 registr√≥ \n * con valores contables at√≠picos \n * para proveedores que no responden a la cuenta 125134.0 \n es de: 5\n\n\n\n# Contar el n√∫mero de filas en el DataFrame vc que cumpla las siguientes condiciones:\n# la columna 'USNAM' debe ser igual a 'GBIFAC-01',\n# la columna 'FIRST' no debe ser uno de los valores [7, 8, 9]\n# la columna 'LIFNR' no debe ser igual a 125134\nre3 = len(vc[(vc['USNAM']=='GBIFAC-01') & ~(vc['FIRST'].isin([7, 8, 9])) & ~(vc['LIFNR'] == 125134)])\n\nprint(f'El n√∫mero de documentos que el contador GBIFAC-01 registr√≥ \\n * con valores contables normales \\n * para cuentas de proveedor que no respondan a 125134.0 \\n es de: {re3}')\n\nEl n√∫mero de documentos que el contador GBIFAC-01 registr√≥ \n * con valores contables normales \n * para cuentas de proveedor que no respondan a 125134.0 \n es de: 79\n\n\n\n# Contar el n√∫mero de filas en el DataFrame vc que cumpla las siguientes condiciones:\n# la columna 'USNAM' debe ser igual a 'GBIFAC-01',\n# la columna 'FIRST' debe ser uno de los valores [7, 8, 9]\n# la columna 'LIFNR' debe ser igual a 125134\nre4 = len(vc[(vc['USNAM']=='GBIFAC-01') & (vc['FIRST'].isin([7, 8, 9])) & (vc['LIFNR'] == 125134)])\n\nprint(f'El n√∫mero de documentos que el contador GBIFAC-01 registr√≥ \\n * con valores contables at√≠picos \\n * para la cuenta de proveedor 125134.0 \\n es de: {re4}')\n\nEl n√∫mero de documentos que el contador GBIFAC-01 registr√≥ \n * con valores contables at√≠picos \n * para la cuenta de proveedor 125134.0 \n es de: 42\n\n\n\n# Contar el n√∫mero de filas en el DataFrame vc que cumpla las siguientes condiciones:\n# la columna 'USNAM' debe ser igual a 'GBIFAC-01',\n# la columna 'FIRST' no debe ser uno de los valores [7, 8, 9]\n# la columna 'LIFNR' debe ser igual a 125134\nre5 = len(vc[(vc['USNAM']=='GBIFAC-01') & ~(vc['FIRST'].isin([7, 8, 9])) & (vc['LIFNR'] == 125134)])\n\nprint(f'El n√∫mero de documentos que el contador GBIFAC-01 registr√≥ \\n * con valores contables normales \\n * para la cuenta de proveedor 125134.0 \\n es de: {re5}')\n\nEl n√∫mero de documentos que el contador GBIFAC-01 registr√≥ \n * con valores contables normales \n * para la cuenta de proveedor 125134.0 \n es de: 4\n\n\n\n# Sumar los valores de la columna 'WRBTR' del DataFrame vc que cumplan con las siguientes condiciones:\n# la columna 'USNAM' debe ser igual a 'GBIFAC-01',\n# la columna 'FIRST' debe ser uno de los valores [7, 8, 9]\n# la columna 'LIFNR' debe ser igual a 125134\nre6 = vc[(vc['USNAM']=='GBIFAC-01') & (vc['FIRST'].isin([7, 8, 9])) & (vc['LIFNR'] == 125134)]['WRBTR'].astype(float).sum()\n\nprint(f'La cantidad total de dinero que el contador GBIFAC-01 registr√≥ \\n * con valores contables at√≠picos \\n * para la cuenta de proveedor 125134.0 \\n es de: {re6}')\n\nLa cantidad total de dinero que el contador GBIFAC-01 registr√≥ \n * con valores contables at√≠picos \n * para la cuenta de proveedor 125134.0 \n es de: 3697715.58\n\n\n\n# Sumar los valores de la columna 'WRBTR' del DataFrame vc que cumplan con las siguientes condiciones:\n# la columna 'USNAM' debe ser igual a 'GBIFAC-01',\n# la columna 'FIRST' no debe ser uno de los valores [7, 8, 9]\n# la columna 'LIFNR' debe ser igual a 125134\nre7 = vc[(vc['USNAM']=='GBIFAC-01') & ~(vc['FIRST'].isin([7, 8, 9])) & (vc['LIFNR'] == 125134)]['WRBTR'].astype(float).sum()\n\nprint(f'La cantidad total de dinero que el contador GBIFAC-01 registr√≥ \\n * con valores contables normales \\n * para la cuenta de proveedor 125134.0 \\n es de: {re7}')\n\nLa cantidad total de dinero que el contador GBIFAC-01 registr√≥ \n * con valores contables normales \n * para la cuenta de proveedor 125134.0 \n es de: 59659.58\n\n\n\nGraficar\n\n# Calcular el porcentaje como fracci√≥n\nporcentaje_fraccion = re6 / vc_total\n\n# Crear una lista con los valores\nvalores = [porcentaje_fraccion, 1 - porcentaje_fraccion]\n\n# Crear una lista con los nombres de las secciones\nnombres = ['vc total con anomal√≠as en la cuenta 125134.0', 'vc total de GBIFAC-01']\n\n# Definir los colores\ncolores = ['#C3797E', '#AFD9A8']\n\n# Crear una figura y un eje\nfig, ax = plt.subplots()\n\n# Graficar la torta\nax.pie(valores, labels=nombres, autopct='%1.1f%%', startangle=90, colors=colores)\n\n# Agregar t√≠tulo a la gr√°fica\nax.set_title('Porcentaje de anomal√≠as en los valores contables frente al valor contable total')\n\n# Mostrar la gr√°fica\nplt.show()"
  },
  {
    "objectID": "CF-Benford-analysis.html#conclusiones",
    "href": "CF-Benford-analysis.html#conclusiones",
    "title": "Algo extra√±o sucede en el departamento de contabilidad‚Ä¶ üëª",
    "section": "Conclusiones:",
    "text": "Conclusiones:\n\nEl contador GBIFAC-01 ha registrado 130 documentos, de los cuales 42 presentan valores at√≠picos en la cuenta de proveedor 125134.0, con un valor contable at√≠pico total de 3697715.58, lo cual representa el 11.3 % del valor total registrado por este contador.\nEs importante tener en cuenta que una desviaci√≥n de la ley de Benford no necesariamente indica fraude o irregularidades contables, sino que podr√≠a ser el resultado de diversas causas, como errores de entrada de datos, sesgos en la selecci√≥n de datos o caracter√≠sticas particulares del conjunto de datos en cuesti√≥n. Por lo tanto, es necesario realizar un an√°lisis m√°s detallado antes de sacar conclusiones definitivas sobre la validez de los valores contables. Pero por el bien de la trama‚Ä¶\nHay que hablar con GBIFAC-01! üò∞ üò°"
  }
]